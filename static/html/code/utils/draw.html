<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>code.utils.draw API documentation</title>
<meta name="description" content="Module containing functions to display, draw, show, and plot useful
information and data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>code.utils.draw</code></h1>
</header>
<section id="section-intro">
<p>Module containing functions to display, draw, show, and plot useful
information and data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing functions to display, draw, show, and plot useful
information and data.
&#34;&#34;&#34;

import cv2
import numpy as np
import pickle as pkl
import random
import time
import matplotlib.pyplot as plt


def print_nicer(msg):
    &#34;&#34;&#34;
    Print the message in a nicer way.
    &#34;&#34;&#34;
    print(&#34;\n\n&#34;)
    print(&#34;-&#34; * 50)
    print(f&#34;# {msg}&#34;)


def print_time_info(start_time, msg=None, time_accumulator=None):
    &#34;&#34;&#34;
    Print the time elapsed from `start_time` until now.
    &#34;&#34;&#34;
    exe_time = time.time() - start_time
    if time_accumulator:
        time_accumulator += exe_time
    if msg:
        print(f&#34;\n# {msg}&#34;)
    print(&#34;\tTime: {:.4f} s&#34;.format(exe_time))


def step_generator():
    &#34;&#34;&#34;
    Generator returning an incremented counter at every call.
    &#34;&#34;&#34;
    start = 1
    while True:
        yield start
        start += 1


def print_next_step_info(generator, title, same_line=False):
    &#34;&#34;&#34;
    Print processing information at every call.
    &#34;&#34;&#34;
    step = next(generator)
    if same_line:
        print(f&#34;\tStep {step}: {title}\r&#34;, end=&#39;&#39;)
    else:
        print(f&#34;\n\tStep {step}: {title}&#34;)
    # print(&#34;-&#34; * 30)


def show_image_window(title, img, height=None, width=None, wait_key=True):
    &#34;&#34;&#34;
    Create a window showing the given image with the given title.
    NO BLOCKING: all images are shown at the end of the script execution.
    &#34;&#34;&#34;
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure()
    plt.axis(&#39;off&#39;)
    plt.title(title)
    plt.imshow(img_rgb)


def show_image_window_blocking(title, img, height=None, width=None, wait_key=True):
    &#34;&#34;&#34;
    Create a window showing the given image with the given title.
    BLOCKING: each image is shown when it is created and a button
    must be pressed to continue the execution (mainly used for debugging)
    &#34;&#34;&#34;
    cv2.namedWindow(title, cv2.WINDOW_NORMAL)
    if height is not None and width is not None:
        cv2.resizeWindow(title, width, height)
    cv2.imshow(title, img)
    if wait_key:
        cv2.waitKey(0)


def draw_people_bounding_box(img, people_bounding_boxes, scale_factor):
    &#34;&#34;&#34;
    Draws the bounding box of people detected in the image.
    &#34;&#34;&#34;
    for box in people_bounding_boxes:
        x, y, w, h = box

        label = &#34;Person&#34;
        color = (96, 128, 0)
        bbox_line_thickness = round(3 * scale_factor)
        cv2.rectangle(img, (x, y), (x + w, y + h), color, bbox_line_thickness)

        font_scale = 1.5 * scale_factor
        line_thickness = round(2 * scale_factor)
        t_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_PLAIN, font_scale, line_thickness)[0]
        c2 = x + t_size[0] + 3, y + t_size[1] + 4
        cv2.rectangle(img, (x, y), c2, color, -1)
        cv2.putText(img, label, (x, y + t_size[1] + 4), cv2.FONT_HERSHEY_PLAIN, font_scale, [225, 255, 255],
                    line_thickness)
    return img


def draw_lines(img, lines, probabilistic_mode=True):
    &#34;&#34;&#34;
    Draw Hough lines on the received image. The lines could
    be obained with or without the Probabilistic version of the
    Hough algorithm.
    &#34;&#34;&#34;
    # Draw the lines:
    # copy edges to the images that will display the results in BGR
    cdst = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)

    if probabilistic_mode:
        if lines is not None:
            for i in range(0, len(lines)):
                l = lines[i][0]
                cv2.line(cdst, (l[0], l[1]), (l[2], l[3]), (0, 0, 255), 3, cv2.LINE_AA)
    else:
        if lines is not None:
            for i in range(0, len(lines)):
                rho = lines[i][0][0]
                theta = lines[i][0][1]
                a = np.cos(theta)
                b = np.sin(theta)
                x0 = a * rho
                y0 = b * rho
                lenght = 20000
                pt1 = (int(x0 + lenght * (-b)), int(y0 + lenght * (a)))
                pt2 = (int(x0 - lenght * (-b)), int(y0 - lenght * (a)))
                cv2.line(cdst, pt1, pt2, (0, 0, 255), 3, cv2.LINE_AA)

    return cdst


def draw_corners(img, corners):
    &#34;&#34;&#34;
    Draws the corners on the given image.
    &#34;&#34;&#34;
    for i in corners:
        x, y = i.ravel()
        cv2.circle(img, (x, y), 3, 255, -1)


def draw_room_info(img, people_room, scale_factor):
    &#34;&#34;&#34;Draws information about the room where paintings and people are located.

        Parameters
        ----------
        img: ndarray
            the input image
        people_room: int or None
            number of the room where the paintings and people are located
        scale_factor: float
            scale factor for which the original image was scaled

        Returns
        -------
        ndarray
            a copy of the input image on which the information about the room
            were drawn.
    &#34;&#34;&#34;

    h = img.shape[0]
    w = img.shape[1]

    if people_room != -1:
        if people_room is not None:
            room = f&#34;Room: {people_room}&#34;
        else:
            room = &#34;Room: --&#34;

        # Draw the room of the painting
        font = cv2.FONT_HERSHEY_PLAIN
        font_scale = 2 * scale_factor
        line_thickness = round(2 * scale_factor)
        font_color = (0, 0, 0)
        room_width, room_height = cv2.getTextSize(
            room,
            font,
            font_scale,
            line_thickness
        )[0]
        # xb_room = int(w / 2 - room_width / 2)
        xb_room = int(20)
        yb_room = int(h - 20)

        bottom_left_corner_of_room = (xb_room, yb_room)

        cv2.rectangle(
            img,
            (xb_room - 15, yb_room - room_height - 15),
            (xb_room + room_width + 15, h - 5),
            (255, 255, 255),
            -1
        )
        cv2.putText(img,
                    room,
                    bottom_left_corner_of_room,
                    font,
                    font_scale,
                    font_color,
                    line_thickness)

    return img


def draw_paintings_info(img, paintings, scale_factor):
    &#34;&#34;&#34;Draws all information about paintings found in the image.

    Parameters
    ----------
    img: ndarray
        the input image
    paintings: list
        list of painting found in the image
    scale_factor: float
        scale factor for which the original image was scaled

    Returns
    -------
    ndarray
        a copy of the input image on which all the information of
        the paintings found in it were drawn.

    Notes
    -----
    For details visit:
    - https://docs.opencv.org/3.4/d6/d6e/group__imgproc__draw.html
    - https://stackoverflow.com/questions/16615662/how-to-write-text-on-a-image-in-windows-using-python-opencv2
    &#34;&#34;&#34;

    h = img.shape[0]
    w = img.shape[1]

    font = cv2.FONT_HERSHEY_PLAIN
    font_scale = 1.5 * scale_factor
    font_color = (255, 255, 255)
    line_thickness = round(1 * scale_factor)

    for painting in paintings:
        corner_points = painting.corners

        if painting.title:
            # Color if painting is detected
            bbox_color = (153, 51, 0)
            # bbox_color = (5, 40, 255)
        else:
            # Color if painting is not detected
            bbox_color = (255, 102, 26)
            # bbox_color = (102, 133, 255)

        # Draw painting outline first, in order to not overlap painting info
        tl = tuple(corner_points[0])
        tr = tuple(corner_points[1])
        bl = tuple(corner_points[3])
        br = tuple(corner_points[2])
        bbox_line_thickness = round(3 * scale_factor)
        cv2.line(img, tl, tr, bbox_color, bbox_line_thickness)
        cv2.line(img, tr, br, bbox_color, bbox_line_thickness)
        cv2.line(img, br, bl, bbox_color, bbox_line_thickness)
        cv2.line(img, bl, tl, bbox_color, bbox_line_thickness)

        if painting.title is not None:
            # Draw the title of the painting
            title = f&#34;{painting.title}&#34;

            # Find position of text above painting
            top = np.min(corner_points[:, 1])
            bottom = np.max(corner_points[:, 1])
            left = corner_points[0][0]
            # left = np.min(corner_points[:, 0])
            right = np.max(corner_points[:, 0])

            title_width, title_height = cv2.getTextSize(
                title,
                font,
                font_scale,
                line_thickness
            )[0]

            # xb_title = int(left + (right - left) / 2 - title_width / 2)
            xb_title = int(left)
            yb_title = int(top - title_height)

            padding = 5

            # Check if the painting title is inside the video frame
            if yb_title - title_height &lt; 0:
                yb_title = int(top + title_height + padding)

            cv2.rectangle(
                img,
                (xb_title - padding, yb_title - title_height - padding),
                (xb_title + title_width + padding, yb_title + padding),
                bbox_color,
                -1
            )

            bottom_left_corner_of_title = (xb_title, yb_title)

            cv2.putText(img,
                        title,
                        bottom_left_corner_of_title,
                        font,
                        font_scale,
                        font_color,
                        line_thickness)

        # show_image(&#34;partial_final_frame&#34;, img, height=405, width=720)

        # cv2.waitKey(0)
    return img</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="code.utils.draw.draw_corners"><code class="name flex">
<span>def <span class="ident">draw_corners</span></span>(<span>img, corners)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the corners on the given image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_corners(img, corners):
    &#34;&#34;&#34;
    Draws the corners on the given image.
    &#34;&#34;&#34;
    for i in corners:
        x, y = i.ravel()
        cv2.circle(img, (x, y), 3, 255, -1)</code></pre>
</details>
</dd>
<dt id="code.utils.draw.draw_lines"><code class="name flex">
<span>def <span class="ident">draw_lines</span></span>(<span>img, lines, probabilistic_mode=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw Hough lines on the received image. The lines could
be obained with or without the Probabilistic version of the
Hough algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_lines(img, lines, probabilistic_mode=True):
    &#34;&#34;&#34;
    Draw Hough lines on the received image. The lines could
    be obained with or without the Probabilistic version of the
    Hough algorithm.
    &#34;&#34;&#34;
    # Draw the lines:
    # copy edges to the images that will display the results in BGR
    cdst = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)

    if probabilistic_mode:
        if lines is not None:
            for i in range(0, len(lines)):
                l = lines[i][0]
                cv2.line(cdst, (l[0], l[1]), (l[2], l[3]), (0, 0, 255), 3, cv2.LINE_AA)
    else:
        if lines is not None:
            for i in range(0, len(lines)):
                rho = lines[i][0][0]
                theta = lines[i][0][1]
                a = np.cos(theta)
                b = np.sin(theta)
                x0 = a * rho
                y0 = b * rho
                lenght = 20000
                pt1 = (int(x0 + lenght * (-b)), int(y0 + lenght * (a)))
                pt2 = (int(x0 - lenght * (-b)), int(y0 - lenght * (a)))
                cv2.line(cdst, pt1, pt2, (0, 0, 255), 3, cv2.LINE_AA)

    return cdst</code></pre>
</details>
</dd>
<dt id="code.utils.draw.draw_paintings_info"><code class="name flex">
<span>def <span class="ident">draw_paintings_info</span></span>(<span>img, paintings, scale_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws all information about paintings found in the image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>the input image</dd>
<dt><strong><code>paintings</code></strong> :&ensp;<code>list</code></dt>
<dd>list of painting found in the image</dd>
<dt><strong><code>scale_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>scale factor for which the original image was scaled</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>a copy of the input image on which all the information of
the paintings found in it were drawn.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For details visit:
- <a href="https://docs.opencv.org/3.4/d6/d6e/group__imgproc__draw.html">https://docs.opencv.org/3.4/d6/d6e/group__imgproc__draw.html</a>
- <a href="https://stackoverflow.com/questions/16615662/how-to-write-text-on-a-image-in-windows-using-python-opencv2">https://stackoverflow.com/questions/16615662/how-to-write-text-on-a-image-in-windows-using-python-opencv2</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_paintings_info(img, paintings, scale_factor):
    &#34;&#34;&#34;Draws all information about paintings found in the image.

    Parameters
    ----------
    img: ndarray
        the input image
    paintings: list
        list of painting found in the image
    scale_factor: float
        scale factor for which the original image was scaled

    Returns
    -------
    ndarray
        a copy of the input image on which all the information of
        the paintings found in it were drawn.

    Notes
    -----
    For details visit:
    - https://docs.opencv.org/3.4/d6/d6e/group__imgproc__draw.html
    - https://stackoverflow.com/questions/16615662/how-to-write-text-on-a-image-in-windows-using-python-opencv2
    &#34;&#34;&#34;

    h = img.shape[0]
    w = img.shape[1]

    font = cv2.FONT_HERSHEY_PLAIN
    font_scale = 1.5 * scale_factor
    font_color = (255, 255, 255)
    line_thickness = round(1 * scale_factor)

    for painting in paintings:
        corner_points = painting.corners

        if painting.title:
            # Color if painting is detected
            bbox_color = (153, 51, 0)
            # bbox_color = (5, 40, 255)
        else:
            # Color if painting is not detected
            bbox_color = (255, 102, 26)
            # bbox_color = (102, 133, 255)

        # Draw painting outline first, in order to not overlap painting info
        tl = tuple(corner_points[0])
        tr = tuple(corner_points[1])
        bl = tuple(corner_points[3])
        br = tuple(corner_points[2])
        bbox_line_thickness = round(3 * scale_factor)
        cv2.line(img, tl, tr, bbox_color, bbox_line_thickness)
        cv2.line(img, tr, br, bbox_color, bbox_line_thickness)
        cv2.line(img, br, bl, bbox_color, bbox_line_thickness)
        cv2.line(img, bl, tl, bbox_color, bbox_line_thickness)

        if painting.title is not None:
            # Draw the title of the painting
            title = f&#34;{painting.title}&#34;

            # Find position of text above painting
            top = np.min(corner_points[:, 1])
            bottom = np.max(corner_points[:, 1])
            left = corner_points[0][0]
            # left = np.min(corner_points[:, 0])
            right = np.max(corner_points[:, 0])

            title_width, title_height = cv2.getTextSize(
                title,
                font,
                font_scale,
                line_thickness
            )[0]

            # xb_title = int(left + (right - left) / 2 - title_width / 2)
            xb_title = int(left)
            yb_title = int(top - title_height)

            padding = 5

            # Check if the painting title is inside the video frame
            if yb_title - title_height &lt; 0:
                yb_title = int(top + title_height + padding)

            cv2.rectangle(
                img,
                (xb_title - padding, yb_title - title_height - padding),
                (xb_title + title_width + padding, yb_title + padding),
                bbox_color,
                -1
            )

            bottom_left_corner_of_title = (xb_title, yb_title)

            cv2.putText(img,
                        title,
                        bottom_left_corner_of_title,
                        font,
                        font_scale,
                        font_color,
                        line_thickness)

        # show_image(&#34;partial_final_frame&#34;, img, height=405, width=720)

        # cv2.waitKey(0)
    return img</code></pre>
</details>
</dd>
<dt id="code.utils.draw.draw_people_bounding_box"><code class="name flex">
<span>def <span class="ident">draw_people_bounding_box</span></span>(<span>img, people_bounding_boxes, scale_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the bounding box of people detected in the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_people_bounding_box(img, people_bounding_boxes, scale_factor):
    &#34;&#34;&#34;
    Draws the bounding box of people detected in the image.
    &#34;&#34;&#34;
    for box in people_bounding_boxes:
        x, y, w, h = box

        label = &#34;Person&#34;
        color = (96, 128, 0)
        bbox_line_thickness = round(3 * scale_factor)
        cv2.rectangle(img, (x, y), (x + w, y + h), color, bbox_line_thickness)

        font_scale = 1.5 * scale_factor
        line_thickness = round(2 * scale_factor)
        t_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_PLAIN, font_scale, line_thickness)[0]
        c2 = x + t_size[0] + 3, y + t_size[1] + 4
        cv2.rectangle(img, (x, y), c2, color, -1)
        cv2.putText(img, label, (x, y + t_size[1] + 4), cv2.FONT_HERSHEY_PLAIN, font_scale, [225, 255, 255],
                    line_thickness)
    return img</code></pre>
</details>
</dd>
<dt id="code.utils.draw.draw_room_info"><code class="name flex">
<span>def <span class="ident">draw_room_info</span></span>(<span>img, people_room, scale_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws information about the room where paintings and people are located.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>the input image</dd>
<dt><strong><code>people_room</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>number of the room where the paintings and people are located</dd>
<dt><strong><code>scale_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>scale factor for which the original image was scaled</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>a copy of the input image on which the information about the room
were drawn.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_room_info(img, people_room, scale_factor):
    &#34;&#34;&#34;Draws information about the room where paintings and people are located.

        Parameters
        ----------
        img: ndarray
            the input image
        people_room: int or None
            number of the room where the paintings and people are located
        scale_factor: float
            scale factor for which the original image was scaled

        Returns
        -------
        ndarray
            a copy of the input image on which the information about the room
            were drawn.
    &#34;&#34;&#34;

    h = img.shape[0]
    w = img.shape[1]

    if people_room != -1:
        if people_room is not None:
            room = f&#34;Room: {people_room}&#34;
        else:
            room = &#34;Room: --&#34;

        # Draw the room of the painting
        font = cv2.FONT_HERSHEY_PLAIN
        font_scale = 2 * scale_factor
        line_thickness = round(2 * scale_factor)
        font_color = (0, 0, 0)
        room_width, room_height = cv2.getTextSize(
            room,
            font,
            font_scale,
            line_thickness
        )[0]
        # xb_room = int(w / 2 - room_width / 2)
        xb_room = int(20)
        yb_room = int(h - 20)

        bottom_left_corner_of_room = (xb_room, yb_room)

        cv2.rectangle(
            img,
            (xb_room - 15, yb_room - room_height - 15),
            (xb_room + room_width + 15, h - 5),
            (255, 255, 255),
            -1
        )
        cv2.putText(img,
                    room,
                    bottom_left_corner_of_room,
                    font,
                    font_scale,
                    font_color,
                    line_thickness)

    return img</code></pre>
</details>
</dd>
<dt id="code.utils.draw.print_next_step_info"><code class="name flex">
<span>def <span class="ident">print_next_step_info</span></span>(<span>generator, title, same_line=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Print processing information at every call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_next_step_info(generator, title, same_line=False):
    &#34;&#34;&#34;
    Print processing information at every call.
    &#34;&#34;&#34;
    step = next(generator)
    if same_line:
        print(f&#34;\tStep {step}: {title}\r&#34;, end=&#39;&#39;)
    else:
        print(f&#34;\n\tStep {step}: {title}&#34;)</code></pre>
</details>
</dd>
<dt id="code.utils.draw.print_nicer"><code class="name flex">
<span>def <span class="ident">print_nicer</span></span>(<span>msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the message in a nicer way.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_nicer(msg):
    &#34;&#34;&#34;
    Print the message in a nicer way.
    &#34;&#34;&#34;
    print(&#34;\n\n&#34;)
    print(&#34;-&#34; * 50)
    print(f&#34;# {msg}&#34;)</code></pre>
</details>
</dd>
<dt id="code.utils.draw.print_time_info"><code class="name flex">
<span>def <span class="ident">print_time_info</span></span>(<span>start_time, msg=None, time_accumulator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the time elapsed from <code>start_time</code> until now.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_time_info(start_time, msg=None, time_accumulator=None):
    &#34;&#34;&#34;
    Print the time elapsed from `start_time` until now.
    &#34;&#34;&#34;
    exe_time = time.time() - start_time
    if time_accumulator:
        time_accumulator += exe_time
    if msg:
        print(f&#34;\n# {msg}&#34;)
    print(&#34;\tTime: {:.4f} s&#34;.format(exe_time))</code></pre>
</details>
</dd>
<dt id="code.utils.draw.show_image_window"><code class="name flex">
<span>def <span class="ident">show_image_window</span></span>(<span>title, img, height=None, width=None, wait_key=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a window showing the given image with the given title.
NO BLOCKING: all images are shown at the end of the script execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_image_window(title, img, height=None, width=None, wait_key=True):
    &#34;&#34;&#34;
    Create a window showing the given image with the given title.
    NO BLOCKING: all images are shown at the end of the script execution.
    &#34;&#34;&#34;
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure()
    plt.axis(&#39;off&#39;)
    plt.title(title)
    plt.imshow(img_rgb)</code></pre>
</details>
</dd>
<dt id="code.utils.draw.show_image_window_blocking"><code class="name flex">
<span>def <span class="ident">show_image_window_blocking</span></span>(<span>title, img, height=None, width=None, wait_key=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a window showing the given image with the given title.
BLOCKING: each image is shown when it is created and a button
must be pressed to continue the execution (mainly used for debugging)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_image_window_blocking(title, img, height=None, width=None, wait_key=True):
    &#34;&#34;&#34;
    Create a window showing the given image with the given title.
    BLOCKING: each image is shown when it is created and a button
    must be pressed to continue the execution (mainly used for debugging)
    &#34;&#34;&#34;
    cv2.namedWindow(title, cv2.WINDOW_NORMAL)
    if height is not None and width is not None:
        cv2.resizeWindow(title, width, height)
    cv2.imshow(title, img)
    if wait_key:
        cv2.waitKey(0)</code></pre>
</details>
</dd>
<dt id="code.utils.draw.step_generator"><code class="name flex">
<span>def <span class="ident">step_generator</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator returning an incremented counter at every call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_generator():
    &#34;&#34;&#34;
    Generator returning an incremented counter at every call.
    &#34;&#34;&#34;
    start = 1
    while True:
        yield start
        start += 1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="code.utils" href="index.html">code.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="code.utils.draw.draw_corners" href="#code.utils.draw.draw_corners">draw_corners</a></code></li>
<li><code><a title="code.utils.draw.draw_lines" href="#code.utils.draw.draw_lines">draw_lines</a></code></li>
<li><code><a title="code.utils.draw.draw_paintings_info" href="#code.utils.draw.draw_paintings_info">draw_paintings_info</a></code></li>
<li><code><a title="code.utils.draw.draw_people_bounding_box" href="#code.utils.draw.draw_people_bounding_box">draw_people_bounding_box</a></code></li>
<li><code><a title="code.utils.draw.draw_room_info" href="#code.utils.draw.draw_room_info">draw_room_info</a></code></li>
<li><code><a title="code.utils.draw.print_next_step_info" href="#code.utils.draw.print_next_step_info">print_next_step_info</a></code></li>
<li><code><a title="code.utils.draw.print_nicer" href="#code.utils.draw.print_nicer">print_nicer</a></code></li>
<li><code><a title="code.utils.draw.print_time_info" href="#code.utils.draw.print_time_info">print_time_info</a></code></li>
<li><code><a title="code.utils.draw.show_image_window" href="#code.utils.draw.show_image_window">show_image_window</a></code></li>
<li><code><a title="code.utils.draw.show_image_window_blocking" href="#code.utils.draw.show_image_window_blocking">show_image_window_blocking</a></code></li>
<li><code><a title="code.utils.draw.step_generator" href="#code.utils.draw.step_generator">step_generator</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>